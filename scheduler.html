---
layout: null
permalink: /scheduler
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shift Optimiser (Prototype)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18",
        "react-dom/client": "https://esm.sh/react-dom@18/client",
        "lucide-react": "https://esm.sh/lucide-react@0.454.0?external=react"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>
    <script type="module">
import * as React from 'react';
import { createRoot } from 'react-dom/client';
import { Plus, Trash2, Calendar, Users, Grid3X3, Zap, Star, Clock, Pencil, Check, X, Save, Upload, ChevronLeft, ChevronRight, Search } from 'lucide-react';

const { useState, useEffect, useRef } = React;
const h = React.createElement;

const PreferenceModal = ({ shift, participant, preference, onSave, onClose }) => {
  const [value, setValue] = useState(preference);
  const modalRef = useRef(null);

  useEffect(() => {
    const handleClickOutside = (e) => {
      if (modalRef.current && !modalRef.current.contains(e.target)) {
        onClose();
      }
    };
    const handleEscape = (e) => {
      if (e.key === 'Escape') onClose();
    };
    document.addEventListener('mousedown', handleClickOutside);
    document.addEventListener('keydown', handleEscape);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('keydown', handleEscape);
    };
  }, [onClose]);

  const handleSave = () => {
    onSave(value);
    onClose();
  };

  return h('div', { className: 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4' },
    h('div', { ref: modalRef, className: 'bg-white rounded-xl shadow-xl max-w-sm w-full p-6' },
      h('h3', { className: 'text-lg font-semibold text-slate-800 mb-1' }, shift.name),
      h('div', { className: 'text-sm text-slate-500 mb-4' },
        shift.date, shift.time && ` at ${shift.time}`, ` â€¢ ${shift.pa} PA`
      ),
      h('div', { className: 'mb-4' },
        h('label', { className: 'block text-sm font-medium text-slate-700 mb-2' },
          `${participant.name}'s preference:`
        ),
        h('div', { className: 'flex justify-center gap-2 py-3' },
          [1, 2, 3, 4, 5].map((star) =>
            h('button', {
              key: star,
              onClick: () => setValue(value === star ? 0 : star),
              className: 'p-1 hover:scale-110 transition-transform'
            },
              h(Star, {
                size: 32,
                className: star <= value ? 'fill-amber-400 text-amber-400' : 'text-gray-300'
              })
            )
          )
        ),
        h('p', { className: 'text-center text-sm text-slate-500 mt-2' },
          value === 0 ? 'Cannot do this shift' :
          value === 1 ? 'Would rather not' :
          value === 2 ? 'If needed' :
          value === 3 ? 'Happy to do' :
          value === 4 ? 'Prefer this shift' :
          'Would love to do this!'
        )
      ),
      h('div', { className: 'flex gap-3' },
        h('button', {
          onClick: onClose,
          className: 'flex-1 px-4 py-2 border border-slate-300 text-slate-700 rounded-lg hover:bg-slate-50 font-medium'
        }, 'Cancel'),
        h('button', {
          onClick: handleSave,
          className: 'flex-1 px-4 py-2 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 font-medium'
        }, 'Save')
      )
    )
  );
};

const StarRating = ({ value, onChange }) => {
  return h('div', { className: 'flex gap-0.5' },
    [1, 2, 3, 4, 5].map((star) =>
      h('button', {
        key: star,
        onClick: () => onChange(value === star ? 0 : star),
        className: 'p-0.5 hover:scale-110 transition-transform'
      },
        h(Star, {
          size: 18,
          className: star <= value ? 'fill-amber-400 text-amber-400' : 'text-gray-300'
        })
      )
    )
  );
};

const optimizeAsync = async (shifts, participants, preferences, onProgress) => {
  if (shifts.length === 0 || participants.length === 0) return null;

  // Find shifts where nobody is available (all preferences are 0)
  const unavailableShifts = shifts.filter(shift =>
    participants.every(p => (preferences[p.id]?.[shift.id] ?? 0) === 0)
  );

  if (unavailableShifts.length > 0) {
    return { failed: true, unavailableShifts };
  }

  let lastProgressUpdate = Date.now();
  let iterations = 0;

  // Track current restart for progress reporting
  let currentRestart = 0;

  // Configuration for restarts (defined here so updateProgress can reference it)
  const numRestarts = 15;

  // Track global best score for display (only increases)
  let globalBestScore = null;

  const updateProgress = async (phase, progress, currentScore) => {
    const now = Date.now();
    if (now - lastProgressUpdate > 50) {
      lastProgressUpdate = now;
      // Update global best if current score is better
      if (currentScore !== null && (globalBestScore === null || currentScore > globalBestScore)) {
        globalBestScore = currentScore;
      }
      onProgress({ phase, progress, iterations, bestScore: globalBestScore, restart: currentRestart, totalRestarts: numRestarts });
      await new Promise(r => setTimeout(r, 0));
    }
  };

  // Calculate how far below quota a participant is
  const getQuotaDeficit = (pId, paTotals) => {
    const p = participants.find(x => x.id === pId);
    return Math.max(0, (p?.paQuota || 0) - (paTotals[pId] || 0));
  };

  // Score a candidate for a shift considering preference and quota needs
  const scoreCandidate = (pId, shiftId, shiftPa, paTotals) => {
    const pref = preferences[pId]?.[shiftId] ?? 0;
    if (pref === 0) return -Infinity;

    const deficit = getQuotaDeficit(pId, paTotals);
    // Prioritize people who need more PA to meet quota
    const quotaBonus = deficit > 0 ? Math.min(deficit, shiftPa) * 2 : 0;
    return pref + quotaBonus;
  };

  // Greedy initial assignment
  const greedyAssign = async () => {
    const assignment = {};
    const paTotals = {};
    participants.forEach(p => paTotals[p.id] = 0);
    let score = 0;

    // Sort shifts by difficulty (fewer available candidates first)
    const sortedShifts = [...shifts].sort((a, b) => {
      const aChoices = participants.filter(p => (preferences[p.id]?.[a.id] ?? 0) > 0).length;
      const bChoices = participants.filter(p => (preferences[p.id]?.[b.id] ?? 0) > 0).length;
      return aChoices - bChoices;
    });

    for (let i = 0; i < sortedShifts.length; i++) {
      const shift = sortedShifts[i];
      iterations++;

      // Yield every 20 shifts to keep UI responsive
      if (i % 20 === 0) {
        await updateProgress('greedy', Math.floor((i / sortedShifts.length) * 50), score);
        await new Promise(r => setTimeout(r, 0));
      }

      // Find best candidate for this shift
      let bestCandidate = null;
      let bestCandidateScore = -Infinity;

      for (const p of participants) {
        const candidateScore = scoreCandidate(p.id, shift.id, shift.pa || 0, paTotals);
        if (candidateScore > bestCandidateScore) {
          bestCandidateScore = candidateScore;
          bestCandidate = p.id;
        }
      }

      if (bestCandidate) {
        assignment[shift.id] = bestCandidate;
        paTotals[bestCandidate] += shift.pa || 0;
        score += preferences[bestCandidate]?.[shift.id] ?? 0;
      }
    }

    return { assignment, paTotals, score };
  };

  // Local search improvement: try swapping assignments
  const localSearch = async (initial, maxPasses = 10) => {
    let current = { ...initial };
    let improved = true;
    let pass = 0;

    while (improved && pass < maxPasses) {
      improved = false;
      pass++;

      // Try reassigning each shift to a different person
      for (let i = 0; i < shifts.length; i++) {
        const shift = shifts[i];
        iterations++;
        await updateProgress('local-search', 50 + Math.floor((pass / maxPasses) * 25), current.score);

        const currentAssignee = current.assignment[shift.id];
        const currentPref = currentAssignee ? (preferences[currentAssignee]?.[shift.id] ?? 0) : 0;

        for (const p of participants) {
          if (p.id === currentAssignee) continue;
          const newPref = preferences[p.id]?.[shift.id] ?? 0;
          if (newPref === 0) continue;

          // Calculate score change
          const scoreChange = newPref - currentPref;

          // Check quota impact
          const newPaTotals = { ...current.paTotals };
          if (currentAssignee) {
            newPaTotals[currentAssignee] -= shift.pa || 0;
          }
          newPaTotals[p.id] = (newPaTotals[p.id] || 0) + (shift.pa || 0);

          const oldDeficitSum = participants.reduce((sum, x) => sum + getQuotaDeficit(x.id, current.paTotals), 0);
          const newDeficitSum = participants.reduce((sum, x) => sum + getQuotaDeficit(x.id, newPaTotals), 0);
          const deficitImprovement = oldDeficitSum - newDeficitSum;

          // Accept if it improves quota situation or improves score without hurting quotas
          if (deficitImprovement > 0 || (deficitImprovement >= 0 && scoreChange > 0)) {
            current.assignment[shift.id] = p.id;
            current.paTotals = newPaTotals;
            current.score += scoreChange;
            improved = true;
            break;
          }
        }
      }

      // Try swapping assignments between two shifts
      for (let i = 0; i < shifts.length && !improved; i++) {
        for (let j = i + 1; j < shifts.length; j++) {
          iterations++;
          const shiftA = shifts[i];
          const shiftB = shifts[j];
          const personA = current.assignment[shiftA.id];
          const personB = current.assignment[shiftB.id];

          if (!personA || !personB || personA === personB) continue;

          // Check if swap is valid (both can do each other's shift)
          const prefAforB = preferences[personA]?.[shiftB.id] ?? 0;
          const prefBforA = preferences[personB]?.[shiftA.id] ?? 0;
          if (prefAforB === 0 || prefBforA === 0) continue;

          const oldScore = (preferences[personA]?.[shiftA.id] ?? 0) + (preferences[personB]?.[shiftB.id] ?? 0);
          const newScore = prefAforB + prefBforA;

          if (newScore > oldScore) {
            current.assignment[shiftA.id] = personB;
            current.assignment[shiftB.id] = personA;
            current.score += newScore - oldScore;
            improved = true;
            break;
          }
        }
      }
    }

    return current;
  };

  // Evaluate solution quality (lower is better for deficit, higher for score)
  const evaluateSolution = (sol) => {
    const deficit = participants.reduce((sum, p) => sum + getQuotaDeficit(p.id, sol.paTotals), 0);
    return { deficit, score: sol.score };
  };

  // Compare two solutions: returns true if a is better than b
  const isBetter = (a, b) => {
    const evalA = evaluateSolution(a);
    const evalB = evaluateSolution(b);
    if (evalA.deficit !== evalB.deficit) return evalA.deficit < evalB.deficit;
    return evalA.score > evalB.score;
  };

  // Deep copy a solution
  const copySolution = (sol) => ({
    assignment: { ...sol.assignment },
    paTotals: { ...sol.paTotals },
    score: sol.score
  });

  // Simulated annealing with reheating for thorough exploration
  const simulatedAnnealing = async (initial, maxIterations = 50000, progressBase = 0, progressRange = 25) => {
    let current = copySolution(initial);
    let best = copySolution(current);
    let temperature = 20;
    const coolingRate = 0.9995;
    const reheatInterval = 10000;
    let itersSinceImprovement = 0;
    let lastYield = Date.now();

    for (let iter = 0; iter < maxIterations; iter++) {
      iterations++;

      // Yield to UI frequently - every 100 iterations or every 30ms
      const now = Date.now();
      if (iter % 100 === 0 || now - lastYield > 30) {
        lastYield = now;
        await updateProgress('annealing', progressBase + Math.floor((iter / maxIterations) * progressRange), best.score);
      }

      // Reheat if stuck
      if (itersSinceImprovement > reheatInterval) {
        temperature = Math.max(temperature, 5);
        itersSinceImprovement = 0;
      }

      // Decide move type: 70% single reassign, 30% swap
      const moveType = Math.random();

      if (moveType < 0.7) {
        // Single reassignment
        const shiftIdx = Math.floor(Math.random() * shifts.length);
        const shift = shifts[shiftIdx];
        const currentAssignee = current.assignment[shift.id];

        const candidates = participants.filter(p =>
          p.id !== currentAssignee && (preferences[p.id]?.[shift.id] ?? 0) > 0
        );
        if (candidates.length === 0) continue;

        const newAssignee = candidates[Math.floor(Math.random() * candidates.length)];
        const oldPref = currentAssignee ? (preferences[currentAssignee]?.[shift.id] ?? 0) : 0;
        const newPref = preferences[newAssignee.id]?.[shift.id] ?? 0;
        const scoreDelta = newPref - oldPref;

        const newPaTotals = { ...current.paTotals };
        if (currentAssignee) newPaTotals[currentAssignee] -= shift.pa || 0;
        newPaTotals[newAssignee.id] = (newPaTotals[newAssignee.id] || 0) + (shift.pa || 0);

        const oldDeficit = participants.reduce((sum, p) => sum + getQuotaDeficit(p.id, current.paTotals), 0);
        const newDeficit = participants.reduce((sum, p) => sum + getQuotaDeficit(p.id, newPaTotals), 0);
        const deficitDelta = oldDeficit - newDeficit;

        const improvement = deficitDelta * 10 + scoreDelta;

        if (improvement > 0 || Math.random() < Math.exp(improvement / temperature)) {
          current.assignment[shift.id] = newAssignee.id;
          current.paTotals = newPaTotals;
          current.score += scoreDelta;

          if (isBetter(current, best)) {
            best = copySolution(current);
            itersSinceImprovement = 0;
          }
        }
      } else {
        // Swap two assignments
        const idxA = Math.floor(Math.random() * shifts.length);
        const idxB = Math.floor(Math.random() * shifts.length);
        if (idxA === idxB) continue;

        const shiftA = shifts[idxA];
        const shiftB = shifts[idxB];
        const personA = current.assignment[shiftA.id];
        const personB = current.assignment[shiftB.id];

        if (!personA || !personB || personA === personB) continue;

        const prefAforB = preferences[personA]?.[shiftB.id] ?? 0;
        const prefBforA = preferences[personB]?.[shiftA.id] ?? 0;
        if (prefAforB === 0 || prefBforA === 0) continue;

        const oldScore = (preferences[personA]?.[shiftA.id] ?? 0) + (preferences[personB]?.[shiftB.id] ?? 0);
        const newScore = prefAforB + prefBforA;
        const scoreDelta = newScore - oldScore;

        if (scoreDelta > 0 || Math.random() < Math.exp(scoreDelta / temperature)) {
          current.assignment[shiftA.id] = personB;
          current.assignment[shiftB.id] = personA;
          current.score += scoreDelta;

          if (isBetter(current, best)) {
            best = copySolution(current);
            itersSinceImprovement = 0;
          }
        }
      }

      itersSinceImprovement++;
      temperature *= coolingRate;
    }

    return best;
  };

  // Thorough local search with 2-opt and 3-opt style moves
  const thoroughLocalSearch = async (initial, maxPasses = 50, progressBase = 0, progressRange = 25) => {
    let current = copySolution(initial);
    let improved = true;
    let pass = 0;
    let opCount = 0;

    while (improved && pass < maxPasses) {
      improved = false;
      pass++;

      // 1-opt: Try reassigning each shift
      for (let i = 0; i < shifts.length; i++) {
        const shift = shifts[i];
        iterations++;
        opCount++;

        // Yield to UI periodically
        if (opCount % 100 === 0) {
          await updateProgress('local-search', progressBase + Math.floor((pass / maxPasses) * progressRange), current.score);
          await new Promise(r => setTimeout(r, 0));
        }

        const currentAssignee = current.assignment[shift.id];
        const currentPref = currentAssignee ? (preferences[currentAssignee]?.[shift.id] ?? 0) : 0;

        let bestCandidate = null;
        let bestImprovement = 0;

        for (const p of participants) {
          if (p.id === currentAssignee) continue;
          const newPref = preferences[p.id]?.[shift.id] ?? 0;
          if (newPref === 0) continue;

          const scoreChange = newPref - currentPref;
          const newPaTotals = { ...current.paTotals };
          if (currentAssignee) newPaTotals[currentAssignee] -= shift.pa || 0;
          newPaTotals[p.id] = (newPaTotals[p.id] || 0) + (shift.pa || 0);

          const oldDeficitSum = participants.reduce((sum, x) => sum + getQuotaDeficit(x.id, current.paTotals), 0);
          const newDeficitSum = participants.reduce((sum, x) => sum + getQuotaDeficit(x.id, newPaTotals), 0);
          const deficitImprovement = oldDeficitSum - newDeficitSum;

          const totalImprovement = deficitImprovement * 10 + scoreChange;
          if (totalImprovement > bestImprovement) {
            bestImprovement = totalImprovement;
            bestCandidate = { pId: p.id, paTotals: newPaTotals, scoreChange };
          }
        }

        if (bestCandidate) {
          current.assignment[shift.id] = bestCandidate.pId;
          current.paTotals = bestCandidate.paTotals;
          current.score += bestCandidate.scoreChange;
          improved = true;
        }
      }

      // 2-opt: Sample random pairs instead of exhaustive search (much faster)
      const numPairSamples = Math.min(shifts.length * 10, 2000);
      for (let sample = 0; sample < numPairSamples; sample++) {
        iterations++;
        opCount++;

        if (opCount % 100 === 0) {
          await updateProgress('local-search', progressBase + Math.floor((pass / maxPasses) * progressRange), current.score);
          await new Promise(r => setTimeout(r, 0));
        }

        const i = Math.floor(Math.random() * shifts.length);
        const j = Math.floor(Math.random() * shifts.length);
        if (i === j) continue;

        const shiftA = shifts[i];
        const shiftB = shifts[j];
        const personA = current.assignment[shiftA.id];
        const personB = current.assignment[shiftB.id];

        if (!personA || !personB || personA === personB) continue;

        const prefAforB = preferences[personA]?.[shiftB.id] ?? 0;
        const prefBforA = preferences[personB]?.[shiftA.id] ?? 0;
        if (prefAforB === 0 || prefBforA === 0) continue;

        const oldScore = (preferences[personA]?.[shiftA.id] ?? 0) + (preferences[personB]?.[shiftB.id] ?? 0);
        const newScore = prefAforB + prefBforA;

        if (newScore > oldScore) {
          current.assignment[shiftA.id] = personB;
          current.assignment[shiftB.id] = personA;
          current.score += newScore - oldScore;
          improved = true;
        }
      }

      // 3-opt: Try cyclic rotations of 3 shifts
      if (pass % 3 === 0) {
        const num3optSamples = Math.min(shifts.length * 5, 1000);
        for (let attempts = 0; attempts < num3optSamples; attempts++) {
          iterations++;
          opCount++;

          if (opCount % 100 === 0) {
            await updateProgress('local-search', progressBase + Math.floor((pass / maxPasses) * progressRange), current.score);
            await new Promise(r => setTimeout(r, 0));
          }

          const idxA = Math.floor(Math.random() * shifts.length);
          const idxB = Math.floor(Math.random() * shifts.length);
          const idxC = Math.floor(Math.random() * shifts.length);
          if (idxA === idxB || idxB === idxC || idxA === idxC) continue;

          const shiftA = shifts[idxA], shiftB = shifts[idxB], shiftC = shifts[idxC];
          const pA = current.assignment[shiftA.id];
          const pB = current.assignment[shiftB.id];
          const pC = current.assignment[shiftC.id];

          if (!pA || !pB || !pC) continue;
          if (pA === pB || pB === pC || pA === pC) continue;

          // Try rotation: A->B's shift, B->C's shift, C->A's shift
          const prefAforB = preferences[pA]?.[shiftB.id] ?? 0;
          const prefBforC = preferences[pB]?.[shiftC.id] ?? 0;
          const prefCforA = preferences[pC]?.[shiftA.id] ?? 0;
          if (prefAforB === 0 || prefBforC === 0 || prefCforA === 0) continue;

          const oldScore = (preferences[pA]?.[shiftA.id] ?? 0) + (preferences[pB]?.[shiftB.id] ?? 0) + (preferences[pC]?.[shiftC.id] ?? 0);
          const newScore = prefAforB + prefBforC + prefCforA;

          if (newScore > oldScore) {
            current.assignment[shiftA.id] = pC;
            current.assignment[shiftB.id] = pA;
            current.assignment[shiftC.id] = pB;
            current.score += newScore - oldScore;
            improved = true;
          }
        }
      }
    }

    return current;
  };

  // Generate initial solution with randomized greedy (for diversity in restarts)
  const randomizedGreedy = async (randomness = 0.3) => {
    const assignment = {};
    const paTotals = {};
    participants.forEach(p => paTotals[p.id] = 0);
    let score = 0;

    // Shuffle shifts partially based on randomness
    const sortedShifts = [...shifts].sort((a, b) => {
      const aChoices = participants.filter(p => (preferences[p.id]?.[a.id] ?? 0) > 0).length;
      const bChoices = participants.filter(p => (preferences[p.id]?.[b.id] ?? 0) > 0).length;
      return (aChoices - bChoices) + (Math.random() - 0.5) * randomness * 20;
    });

    for (let i = 0; i < sortedShifts.length; i++) {
      const shift = sortedShifts[i];
      iterations++;

      // Yield every 20 shifts to keep UI responsive
      if (i % 20 === 0) {
        await new Promise(r => setTimeout(r, 0));
      }

      // Get all valid candidates with scores
      const candidates = [];
      for (const p of participants) {
        const candidateScore = scoreCandidate(p.id, shift.id, shift.pa || 0, paTotals);
        if (candidateScore > -Infinity) {
          candidates.push({ pId: p.id, score: candidateScore });
        }
      }

      if (candidates.length === 0) continue;

      // Sort by score and pick from top candidates with some randomness
      candidates.sort((a, b) => b.score - a.score);
      const topK = Math.min(candidates.length, Math.max(1, Math.floor(candidates.length * randomness)));
      const selected = candidates[Math.floor(Math.random() * topK)];

      assignment[shift.id] = selected.pId;
      paTotals[selected.pId] += shift.pa || 0;
      score += preferences[selected.pId]?.[shift.id] ?? 0;
    }

    return { assignment, paTotals, score };
  };

  // Run the full optimization pipeline with multiple restarts
  // Extended iterations for thorough optimization (targets 3-8 min runtime)
  const annealingIterations = 100000;
  const localSearchPasses = 50;
  const finalPolishPasses = 25;
  let globalBest = null;

  for (let restart = 0; restart < numRestarts; restart++) {
    const restartProgress = (restart / numRestarts) * 100;
    const restartRange = 100 / numRestarts;

    // Update current restart for progress tracking
    currentRestart = restart + 1;

    // Force progress update at start of each restart
    onProgress({ phase: 'greedy', progress: Math.floor(restartProgress), iterations, bestScore: globalBestScore, restart: currentRestart, totalRestarts: numRestarts });
    await new Promise(r => setTimeout(r, 0));

    // Generate initial solution (first one deterministic, rest randomized)
    let result;
    if (restart === 0) {
      result = await greedyAssign();
    } else {
      result = await randomizedGreedy(0.15 + restart * 0.08);
    }

    // Local search phase
    result = await thoroughLocalSearch(result, localSearchPasses, restartProgress + restartRange * 0.05, restartRange * 0.25);

    // Simulated annealing phase (main optimization)
    result = await simulatedAnnealing(result, annealingIterations, restartProgress + restartRange * 0.3, restartRange * 0.55);

    // Final local search polish
    result = await thoroughLocalSearch(result, finalPolishPasses, restartProgress + restartRange * 0.85, restartRange * 0.15);

    // Track global best
    if (!globalBest || isBetter(result, globalBest)) {
      globalBest = copySolution(result);
      // Update the display score tracker
      if (globalBest.score > (globalBestScore ?? -Infinity)) {
        globalBestScore = globalBest.score;
      }
    }
  }

  // Check if quotas were met
  const quotasNotMet = participants.some(p => getQuotaDeficit(p.id, globalBest.paTotals) > 0);

  onProgress({ phase: 'complete', progress: 100, iterations, bestScore: globalBest.score });

  return {
    assignment: globalBest.assignment,
    score: globalBest.score,
    paTotals: globalBest.paTotals,
    quotasNotMet
  };
};

function ShiftOptimizer() {
  const [tab, setTab] = useState('shifts');
  const [shifts, setShifts] = useState([]);
  const [participants, setParticipants] = useState([]);
  const [preferences, setPreferences] = useState({});
  const [newShift, setNewShift] = useState({ name: '', date: '', time: '', pa: '' });
  const [newParticipant, setNewParticipant] = useState({ name: '', paQuota: '' });
  const [result, setResult] = useState(null);
  const [editingShift, setEditingShift] = useState(null);
  const [editingParticipant, setEditingParticipant] = useState(null);
  const [calendarWeekStart, setCalendarWeekStart] = useState(() => {
    const today = new Date();
    const day = today.getDay();
    const diff = today.getDate() - day + (day === 0 ? -6 : 1);
    return new Date(today.setDate(diff));
  });
  const [doctorSearch, setDoctorSearch] = useState('');
  const [resultsWeekStart, setResultsWeekStart] = useState(() => {
    const today = new Date();
    const day = today.getDay();
    const diff = today.getDate() - day + (day === 0 ? -6 : 1);
    return new Date(today.setDate(diff));
  });
  const [prefsWeekStart, setPrefsWeekStart] = useState(() => {
    const today = new Date();
    const day = today.getDay();
    const diff = today.getDate() - day + (day === 0 ? -6 : 1);
    return new Date(today.setDate(diff));
  });
  const [selectedParticipant, setSelectedParticipant] = useState(null);
  const [prefModal, setPrefModal] = useState(null);

  const getWeekDates = (weekStart) => {
    const dates = [];
    for (let i = 0; i < 7; i++) {
      const d = new Date(weekStart);
      d.setDate(weekStart.getDate() + i);
      dates.push(d);
    }
    return dates;
  };

  const formatDateKey = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  const groupShiftsByDate = (shifts) => {
    const grouped = {};
    shifts.forEach(s => {
      if (!grouped[s.date]) grouped[s.date] = [];
      grouped[s.date].push(s);
    });
    Object.keys(grouped).forEach(date => {
      grouped[date].sort((a, b) => (a.time || '').localeCompare(b.time || ''));
    });
    return grouped;
  };

  const formatWeekRange = (weekStart) => {
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    const options = { day: 'numeric', month: 'short' };
    const startStr = weekStart.toLocaleDateString('en-GB', options);
    const endStr = weekEnd.toLocaleDateString('en-GB', { ...options, year: 'numeric' });
    return `${startStr} - ${endStr}`;
  };

  const navigateWeek = (direction) => {
    setCalendarWeekStart(prev => {
      const newDate = new Date(prev);
      newDate.setDate(prev.getDate() + (direction * 7));
      return newDate;
    });
  };

  const jumpToShiftsWeek = () => {
    if (shifts.length === 0) return;
    const sortedDates = [...shifts].sort((a, b) => a.date.localeCompare(b.date));
    const firstDate = new Date(sortedDates[0].date);
    const day = firstDate.getDay();
    const diff = firstDate.getDate() - day + (day === 0 ? -6 : 1);
    setCalendarWeekStart(new Date(firstDate.setDate(diff)));
  };

  const navigateResultsWeek = (direction) => {
    setResultsWeekStart(prev => {
      const newDate = new Date(prev);
      newDate.setDate(prev.getDate() + (direction * 7));
      return newDate;
    });
  };

  const jumpToResultsWeek = () => {
    if (shifts.length === 0) return;
    const sortedDates = [...shifts].sort((a, b) => a.date.localeCompare(b.date));
    const firstDate = new Date(sortedDates[0].date);
    const day = firstDate.getDay();
    const diff = firstDate.getDate() - day + (day === 0 ? -6 : 1);
    setResultsWeekStart(new Date(firstDate.setDate(diff)));
  };

  const navigatePrefsWeek = (direction) => {
    setPrefsWeekStart(prev => {
      const newDate = new Date(prev);
      newDate.setDate(prev.getDate() + (direction * 7));
      return newDate;
    });
  };

  const jumpToPrefsWeek = () => {
    if (shifts.length === 0) return;
    const sortedDates = [...shifts].sort((a, b) => a.date.localeCompare(b.date));
    const firstDate = new Date(sortedDates[0].date);
    const day = firstDate.getDay();
    const diff = firstDate.getDate() - day + (day === 0 ? -6 : 1);
    setPrefsWeekStart(new Date(firstDate.setDate(diff)));
  };

  const jumpAllCalendarsToShifts = (shiftList) => {
    if (shiftList.length === 0) return;
    const sortedDates = [...shiftList].sort((a, b) => a.date.localeCompare(b.date));
    const firstDate = new Date(sortedDates[0].date);
    const day = firstDate.getDay();
    const diff = firstDate.getDate() - day + (day === 0 ? -6 : 1);
    const weekStart = new Date(firstDate);
    weekStart.setDate(firstDate.getDate() - day + (day === 0 ? -6 : 1));
    setCalendarWeekStart(new Date(weekStart));
    setResultsWeekStart(new Date(weekStart));
    setPrefsWeekStart(new Date(weekStart));
  };

  const addShift = () => {
    if (!newShift.name || !newShift.date) return;
    setShifts([...shifts, { id: Date.now().toString(), ...newShift, pa: parseFloat(newShift.pa) || 0 }]);
    setNewShift({ name: '', date: '', time: '', pa: '' });
  };

  const addParticipant = () => {
    if (!newParticipant.name.trim()) return;
    const id = Date.now().toString();
    setParticipants([...participants, { id, name: newParticipant.name.trim(), paQuota: parseFloat(newParticipant.paQuota) || 0 }]);
    setPreferences({ ...preferences, [id]: {} });
    setNewParticipant({ name: '', paQuota: '' });
  };

  const startEditShift = (shift) => {
    setEditingShift({ ...shift, pa: shift.pa.toString() });
  };

  const saveEditShift = () => {
    if (!editingShift.name || !editingShift.date) return;
    setShifts(shifts.map(s => s.id === editingShift.id
      ? { ...editingShift, pa: parseFloat(editingShift.pa) || 0 }
      : s
    ));
    setEditingShift(null);
  };

  const startEditParticipant = (participant) => {
    setEditingParticipant({ ...participant, paQuota: participant.paQuota.toString() });
  };

  const saveEditParticipant = () => {
    if (!editingParticipant.name.trim()) return;
    setParticipants(participants.map(p => p.id === editingParticipant.id
      ? { ...editingParticipant, name: editingParticipant.name.trim(), paQuota: parseFloat(editingParticipant.paQuota) || 0 }
      : p
    ));
    setEditingParticipant(null);
  };

  const updatePref = (pId, sId, value) => {
    setPreferences({
      ...preferences,
      [pId]: { ...preferences[pId], [sId]: value }
    });
  };

  const [optimizationError, setOptimizationError] = useState(null);
  const [isOptimizing, setIsOptimizing] = useState(false);
  const [optimizeProgress, setOptimizeProgress] = useState(null);

  const runOptimizer = async () => {
    // Pre-solve capacity check
    const totalPaRequired = shifts.reduce((sum, s) => sum + (s.pa || 0), 0);
    const totalPaCapacity = participants.reduce((sum, p) => sum + (p.paQuota || 0), 0);

    if (totalPaRequired > totalPaCapacity) {
      setTab('results');
      setResult(null);
      setOptimizationError({
        message: 'Insufficient PA capacity',
        capacityShortfall: {
          required: totalPaRequired,
          available: totalPaCapacity,
          shortfall: totalPaRequired - totalPaCapacity
        }
      });
      return;
    }

    setIsOptimizing(true);
    setOptimizeProgress({ phase: 'greedy', progress: 0, iterations: 0, bestScore: null });
    setTab('results');

    // Small delay to let UI update before heavy computation
    await new Promise(r => setTimeout(r, 50));

    const res = await optimizeAsync(shifts, participants, preferences, (progress) => {
      setOptimizeProgress(progress);
    });

    setIsOptimizing(false);
    setOptimizeProgress(null);

    if (res === null) {
      setResult(null);
      setOptimizationError({ message: 'No shifts or participants defined.' });
    } else if (res.failed) {
      setResult(null);
      setOptimizationError({ message: 'Unable to create a schedule', unavailableShifts: res.unavailableShifts });
    } else {
      setResult(res);
      setOptimizationError(null);
    }
  };

  const tabs = [
    { id: 'shifts', label: 'Shifts', icon: Calendar },
    { id: 'participants', label: 'People', icon: Users },
    { id: 'preferences', label: 'Preferences', icon: Grid3X3 },
    { id: 'results', label: 'Results', icon: Zap },
  ];

  const saveToFile = () => {
    const filename = prompt('Enter filename:', 'schedule');
    if (!filename) return;
    const data = {
      version: 1,
      shifts,
      participants,
      preferences
    };
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename.endsWith('.schdl') ? filename : `${filename}.schdl`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const loadFromFile = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.schdl';
    input.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target.result);
          if (data.shifts) {
            setShifts(data.shifts);
            jumpAllCalendarsToShifts(data.shifts);
          }
          if (data.participants) setParticipants(data.participants);
          if (data.preferences) setPreferences(data.preferences);
          setResult(null);
        } catch (err) {
          alert('Failed to load schedule file. Please check the file format.');
        }
      };
      reader.readAsText(file);
    };
    input.click();
  };

  const loadExample = () => {
    // Generate dates starting from next Monday
    const today = new Date();
    const dayOfWeek = today.getDay();
    const daysUntilMonday = dayOfWeek === 0 ? 1 : (8 - dayOfWeek);
    const monday = new Date(today);
    monday.setDate(today.getDate() + daysUntilMonday);

    const getDateStr = (daysFromMonday) => {
      const d = new Date(monday);
      d.setDate(monday.getDate() + daysFromMonday);
      return d.toISOString().split('T')[0];
    };

    // Hospital stress test: 4 weeks of shifts across multiple departments
    const departments = [
      { name: 'ICU', times: ['07:00', '19:00'], pa: 2 },
      { name: 'A&E', times: ['08:00', '14:00', '20:00'], pa: 1.5 },
      { name: 'Surgery', times: ['08:00', '13:00'], pa: 2 },
      { name: 'Paediatrics', times: ['08:00', '18:00'], pa: 1 },
      { name: 'Cardiology', times: ['09:00', '14:00'], pa: 1.5 },
      { name: 'Oncology', times: ['08:00', '14:00'], pa: 1 },
    ];

    const exShifts = [];
    let shiftId = 1;
    // Generate 4 weeks (28 days) of shifts
    for (let day = 0; day < 28; day++) {
      // Skip weekends for most departments except ICU and A&E
      const dayOfWeek = (day % 7);
      const isWeekend = dayOfWeek === 5 || dayOfWeek === 6; // Sat/Sun

      departments.forEach(dept => {
        // ICU and A&E run 7 days, others only weekdays
        if (isWeekend && dept.name !== 'ICU' && dept.name !== 'A&E') return;

        dept.times.forEach(time => {
          exShifts.push({
            id: String(shiftId++),
            name: `${dept.name} ${time < '12:00' ? 'AM' : time < '18:00' ? 'PM' : 'Night'}`,
            date: getDateStr(day),
            time: time,
            pa: dept.pa
          });
        });
      });
    }

    // Calculate total PA required
    const totalPaRequired = exShifts.reduce((sum, s) => sum + s.pa, 0);
    // Set quotas so total capacity roughly matches demand (with slight shortage to make it challenging)
    const targetTotalQuota = totalPaRequired * 0.95; // 5% under capacity
    const numDoctors = 15;
    const baseQuota = Math.floor(targetTotalQuota / numDoctors);

    // 15 doctors with quotas scaled to match shift requirements
    const exPeople = [
      { id: 'd1', name: 'Dr Sarah Mitchell', paQuota: baseQuota + 4 },
      { id: 'd2', name: 'Dr James Chen', paQuota: baseQuota + 2 },
      { id: 'd3', name: 'Dr Emily Watson', paQuota: baseQuota + 6 },
      { id: 'd4', name: 'Dr Raj Patel', paQuota: baseQuota },
      { id: 'd5', name: 'Dr Lucy O\'Brien', paQuota: baseQuota + 4 },
      { id: 'd6', name: 'Dr Michael Brown', paQuota: baseQuota + 2 },
      { id: 'd7', name: 'Dr Aisha Khan', paQuota: baseQuota + 6 },
      { id: 'd8', name: 'Dr David Wilson', paQuota: baseQuota - 2 },
      { id: 'd9', name: 'Dr Sophie Taylor', paQuota: baseQuota + 4 },
      { id: 'd10', name: 'Dr Tom Anderson', paQuota: baseQuota + 2 },
      { id: 'd11', name: 'Dr Hannah Lee', paQuota: baseQuota },
      { id: 'd12', name: 'Dr Chris Martin', paQuota: baseQuota + 4 },
      { id: 'd13', name: 'Dr Priya Sharma', paQuota: baseQuota + 6 },
      { id: 'd14', name: 'Dr Ben Thompson', paQuota: baseQuota + 2 },
      { id: 'd15', name: 'Dr Olivia Clark', paQuota: baseQuota },
    ];

    // Generate random but realistic preferences
    // Doctors tend to prefer certain departments and avoid nights
    const exPrefs = {};
    const seededRandom = (seed) => {
      const x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    };

    exPeople.forEach((doctor, docIdx) => {
      exPrefs[doctor.id] = {};
      // Each doctor has 2-3 preferred departments
      const preferredDepts = departments
        .map((d, i) => ({ dept: d.name, score: seededRandom(docIdx * 100 + i) }))
        .sort((a, b) => b.score - a.score)
        .slice(0, 3)
        .map(d => d.dept);

      exShifts.forEach((shift, shiftIdx) => {
        let pref = 3; // Base preference

        // Boost for preferred departments
        if (preferredDepts.some(d => shift.name.includes(d.split(' ')[0]))) {
          pref += 1;
        }

        // Some doctors avoid nights
        if (shift.name.includes('Night') && seededRandom(docIdx * 50) > 0.6) {
          pref -= 2;
        }

        // Add some randomness
        pref += Math.floor(seededRandom(docIdx * 1000 + shiftIdx) * 3) - 1;

        // Clamp between 1 and 5
        pref = Math.max(1, Math.min(5, pref));

        // Some shifts completely unavailable (10% chance)
        if (seededRandom(docIdx * 2000 + shiftIdx) < 0.1) {
          pref = 0;
        }

        exPrefs[doctor.id][shift.id] = pref;
      });
    });

    setShifts(exShifts);
    setParticipants(exPeople);
    setPreferences(exPrefs);
    setResult(null);
    jumpAllCalendarsToShifts(exShifts);
  };

  return h('div', { className: 'min-h-screen bg-slate-50 p-6' },
    h('div', { className: 'max-w-4xl mx-auto' },
      // Header
      h('div', { className: 'flex flex-wrap items-center justify-between gap-3 mb-6' },
        h('h1', { className: 'text-2xl font-bold text-slate-800' }, "Shift Optimiser (Prototype)"),
        h('div', { className: 'flex flex-wrap gap-2' },
          h('button', {
            onClick: saveToFile,
            className: 'px-3 py-2 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 text-sm font-medium flex items-center gap-2'
          }, h(Save, { size: 16 }), 'Save'),
          h('button', {
            onClick: loadFromFile,
            className: 'px-3 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 text-sm font-medium flex items-center gap-2'
          }, h(Upload, { size: 16 }), 'Load'),
          h('button', {
            onClick: loadExample,
            className: 'px-3 py-2 bg-slate-200 text-slate-700 rounded-lg hover:bg-slate-300 text-sm font-medium'
          }, 'Example')
        )
      ),

      // Tabs
      h('div', { className: 'flex flex-wrap gap-2 mb-6' },
        tabs.map(({ id, label, icon: Icon }) =>
          h('button', {
            key: id,
            onClick: () => setTab(id),
            className: `flex items-center gap-2 px-3 py-2 rounded-lg font-medium transition-colors text-sm sm:text-base sm:px-4 ${
              tab === id ? 'bg-indigo-600 text-white' : 'bg-white text-slate-600 hover:bg-slate-100'
            }`
          },
            h(Icon, { size: 18 }),
            label
          )
        )
      ),

      // Content
      h('div', { className: 'bg-white rounded-xl shadow-sm p-6' },
        // Shifts Tab
        tab === 'shifts' && h('div', null,
          h('h2', { className: 'text-lg font-semibold mb-4' }, 'Manage Shifts'),
          h('div', { className: 'flex flex-wrap gap-3 mb-4' },
            h('input', {
              type: 'text',
              placeholder: 'Shift name',
              value: newShift.name,
              onChange: (e) => setNewShift({ ...newShift, name: e.target.value }),
              className: 'flex-1 min-w-[120px] px-3 py-2 border rounded-lg'
            }),
            h('div', { className: 'relative flex items-center' },
              h(Calendar, { size: 16, className: 'absolute left-3 text-slate-400 pointer-events-none' }),
              h('input', {
                type: 'date',
                value: newShift.date,
                onChange: (e) => setNewShift({ ...newShift, date: e.target.value }),
                className: 'pl-9 pr-3 py-2 border rounded-lg'
              })
            ),
            h('div', { className: 'relative flex items-center' },
              h(Clock, { size: 16, className: 'absolute left-3 text-slate-400 pointer-events-none' }),
              h('input', {
                type: 'time',
                value: newShift.time,
                onChange: (e) => setNewShift({ ...newShift, time: e.target.value }),
                className: 'pl-9 pr-3 py-2 border rounded-lg'
              })
            ),
            h('input', {
              type: 'number',
              step: '0.5',
              placeholder: 'PA',
              value: newShift.pa,
              onChange: (e) => setNewShift({ ...newShift, pa: e.target.value }),
              className: 'w-20 px-3 py-2 border rounded-lg'
            }),
            h('button', {
              onClick: addShift,
              className: 'px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 flex items-center gap-2 whitespace-nowrap'
            }, h(Plus, { size: 18 }), ' Add')
          ),
          // Week navigation
          h('div', { className: 'flex items-center justify-between mb-4' },
            h('button', {
              onClick: () => navigateWeek(-1),
              className: 'p-2 text-slate-600 hover:bg-slate-100 rounded-lg'
            }, h(ChevronLeft, { size: 20 })),
            h('div', { className: 'flex items-center gap-2' },
              h('span', { className: 'font-medium text-slate-700' }, formatWeekRange(calendarWeekStart)),
              shifts.length > 0 && h('button', {
                onClick: jumpToShiftsWeek,
                className: 'text-xs px-2 py-1 bg-indigo-100 text-indigo-700 rounded hover:bg-indigo-200'
              }, 'Go to shifts')
            ),
            h('button', {
              onClick: () => navigateWeek(1),
              className: 'p-2 text-slate-600 hover:bg-slate-100 rounded-lg'
            }, h(ChevronRight, { size: 20 }))
          ),
          // Calendar grid
          h('div', { className: 'overflow-x-auto' },
            h('div', { className: 'grid grid-cols-7 gap-2 min-w-[700px]' },
              getWeekDates(calendarWeekStart).map((date) => {
                const dateKey = formatDateKey(date);
                const dayShifts = groupShiftsByDate(shifts)[dateKey] || [];
                const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const isToday = formatDateKey(new Date()) === dateKey;
                return h('div', {
                  key: dateKey,
                  className: `border rounded-lg p-2 min-h-[120px] ${isToday ? 'border-indigo-300 bg-indigo-50/30' : 'border-slate-200'}`
                },
                  h('div', { className: `text-center mb-2 pb-2 border-b ${isToday ? 'border-indigo-200' : 'border-slate-100'}` },
                    h('div', { className: 'text-xs text-slate-500' }, dayNames[date.getDay()]),
                    h('div', { className: `font-semibold ${isToday ? 'text-indigo-600' : 'text-slate-700'}` }, date.getDate())
                  ),
                  h('div', { className: 'space-y-1' },
                    dayShifts.map((s) =>
                      editingShift?.id === s.id
                        ? h('div', { key: s.id, className: 'p-2 bg-indigo-100 rounded text-xs space-y-1' },
                            h('input', {
                              type: 'text',
                              value: editingShift.name,
                              onChange: (e) => setEditingShift({ ...editingShift, name: e.target.value }),
                              className: 'w-full px-1 py-0.5 border rounded text-xs'
                            }),
                            h('input', {
                              type: 'time',
                              value: editingShift.time || '',
                              onChange: (e) => setEditingShift({ ...editingShift, time: e.target.value }),
                              className: 'w-full px-1 py-0.5 border rounded text-xs'
                            }),
                            h('input', {
                              type: 'number',
                              step: '0.5',
                              value: editingShift.pa,
                              onChange: (e) => setEditingShift({ ...editingShift, pa: e.target.value }),
                              placeholder: 'PA',
                              className: 'w-full px-1 py-0.5 border rounded text-xs'
                            }),
                            h('div', { className: 'flex gap-1' },
                              h('button', {
                                onClick: saveEditShift,
                                className: 'flex-1 p-1 text-emerald-600 hover:bg-emerald-50 rounded'
                              }, h(Check, { size: 14 })),
                              h('button', {
                                onClick: () => setEditingShift(null),
                                className: 'flex-1 p-1 text-slate-500 hover:bg-slate-100 rounded'
                              }, h(X, { size: 14 }))
                            )
                          )
                        : h('div', { key: s.id, className: 'p-2 bg-slate-100 rounded text-xs group hover:bg-slate-200' },
                            h('div', { className: 'font-medium text-slate-700 truncate' }, s.name),
                            s.time && h('div', { className: 'text-slate-500' }, s.time),
                            h('div', { className: 'text-indigo-600 font-medium' }, s.pa, ' PA'),
                            h('div', { className: 'flex gap-1 mt-1 opacity-0 group-hover:opacity-100 transition-opacity' },
                              h('button', {
                                onClick: () => startEditShift(s),
                                className: 'p-1 text-indigo-500 hover:bg-indigo-100 rounded'
                              }, h(Pencil, { size: 12 })),
                              h('button', {
                                onClick: () => setShifts(shifts.filter((x) => x.id !== s.id)),
                                className: 'p-1 text-red-500 hover:bg-red-100 rounded'
                              }, h(Trash2, { size: 12 }))
                            )
                          )
                    )
                  )
                );
              })
            )
          ),
          shifts.length === 0 && h('p', { className: 'text-slate-500 text-center py-4 mt-4' }, 'No shifts added yet. Add shifts using the form above.')
        ),

        // Participants Tab
        tab === 'participants' && h('div', null,
          h('h2', { className: 'text-lg font-semibold mb-4' }, 'Manage Participants'),
          h('div', { className: 'flex flex-wrap gap-3 mb-4' },
            h('input', {
              type: 'text',
              placeholder: 'Name',
              value: newParticipant.name,
              onChange: (e) => setNewParticipant({ ...newParticipant, name: e.target.value }),
              onKeyDown: (e) => e.key === 'Enter' && addParticipant(),
              className: 'flex-1 min-w-[120px] px-3 py-2 border rounded-lg'
            }),
            h('input', {
              type: 'number',
              step: '0.5',
              placeholder: 'PA Quota',
              value: newParticipant.paQuota,
              onChange: (e) => setNewParticipant({ ...newParticipant, paQuota: e.target.value }),
              onKeyDown: (e) => e.key === 'Enter' && addParticipant(),
              className: 'w-28 px-3 py-2 border rounded-lg'
            }),
            h('button', {
              onClick: addParticipant,
              className: 'px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 flex items-center gap-2 whitespace-nowrap'
            }, h(Plus, { size: 18 }), ' Add')
          ),
          participants.length === 0
            ? h('p', { className: 'text-slate-500 text-center py-8' }, 'No participants added yet')
            : h('div', { className: 'space-y-2' },
                participants.map((p) =>
                  editingParticipant?.id === p.id
                    ? h('div', { key: p.id, className: 'flex flex-wrap items-center gap-2 p-3 bg-emerald-50 rounded-lg' },
                        h('input', {
                          type: 'text',
                          value: editingParticipant.name,
                          onChange: (e) => setEditingParticipant({ ...editingParticipant, name: e.target.value }),
                          className: 'flex-1 min-w-[120px] px-2 py-1 border rounded'
                        }),
                        h('input', {
                          type: 'number',
                          step: '0.5',
                          value: editingParticipant.paQuota,
                          onChange: (e) => setEditingParticipant({ ...editingParticipant, paQuota: e.target.value }),
                          placeholder: 'PA Quota',
                          className: 'w-24 px-2 py-1 border rounded'
                        }),
                        h('button', {
                          onClick: saveEditParticipant,
                          className: 'p-2 text-emerald-600 hover:bg-emerald-100 rounded'
                        }, h(Check, { size: 18 })),
                        h('button', {
                          onClick: () => setEditingParticipant(null),
                          className: 'p-2 text-slate-500 hover:bg-slate-100 rounded'
                        }, h(X, { size: 18 }))
                      )
                    : h('div', { key: p.id, className: 'flex items-center justify-between gap-2 p-3 bg-slate-50 rounded-lg' },
                        h('div', { className: 'flex flex-wrap items-center gap-2 sm:gap-4 min-w-0' },
                          h('span', { className: 'font-medium' }, p.name),
                          h('span', { className: 'px-2 py-1 bg-emerald-100 text-emerald-700 rounded text-sm font-medium whitespace-nowrap' }, 'Quota: ', p.paQuota, ' PA')
                        ),
                        h('div', { className: 'flex items-center gap-1 flex-shrink-0' },
                          h('button', {
                            onClick: () => startEditParticipant(p),
                            className: 'p-2 text-emerald-500 hover:bg-emerald-50 rounded'
                          }, h(Pencil, { size: 18 })),
                          h('button', {
                            onClick: () => {
                              setParticipants(participants.filter((x) => x.id !== p.id));
                              const newPrefs = { ...preferences };
                              delete newPrefs[p.id];
                              setPreferences(newPrefs);
                            },
                            className: 'p-2 text-red-500 hover:bg-red-50 rounded'
                          }, h(Trash2, { size: 18 }))
                        )
                      )
                )
              )
        ),

        // Preferences Tab
        tab === 'preferences' && h('div', null,
          h('h2', { className: 'text-lg font-semibold mb-4' }, 'Set Preferences'),
          h('p', { className: 'text-slate-500 mb-4' }, 'Select a person, then rate each shift: 0 stars = cannot do, 5 stars = would love to'),
          (shifts.length === 0 || participants.length === 0)
            ? h('p', { className: 'text-slate-500 text-center py-8' }, 'Add shifts and participants first')
            : h('div', null,
                // Participant selector
                h('div', { className: 'mb-4' },
                  h('label', { className: 'block text-sm font-medium text-slate-700 mb-2' }, 'Select Person'),
                  h('div', { className: 'flex flex-wrap gap-2' },
                    participants.map((p) =>
                      h('button', {
                        key: p.id,
                        onClick: () => setSelectedParticipant(p.id),
                        className: `px-3 py-2 rounded-lg text-sm font-medium transition-colors ${
                          selectedParticipant === p.id
                            ? 'bg-emerald-600 text-white'
                            : 'bg-slate-100 text-slate-700 hover:bg-slate-200'
                        }`
                      }, p.name, ' (', p.paQuota, ' PA)')
                    )
                  )
                ),
                // Week navigation
                selectedParticipant && h('div', { className: 'flex items-center justify-between mb-4' },
                  h('button', {
                    onClick: () => navigatePrefsWeek(-1),
                    className: 'p-2 text-slate-600 hover:bg-slate-100 rounded-lg'
                  }, h(ChevronLeft, { size: 20 })),
                  h('div', { className: 'flex items-center gap-2' },
                    h('span', { className: 'font-medium text-slate-700' }, formatWeekRange(prefsWeekStart)),
                    shifts.length > 0 && h('button', {
                      onClick: jumpToPrefsWeek,
                      className: 'text-xs px-2 py-1 bg-indigo-100 text-indigo-700 rounded hover:bg-indigo-200'
                    }, 'Go to shifts')
                  ),
                  h('button', {
                    onClick: () => navigatePrefsWeek(1),
                    className: 'p-2 text-slate-600 hover:bg-slate-100 rounded-lg'
                  }, h(ChevronRight, { size: 20 }))
                ),
                // Preferences calendar grid
                selectedParticipant && h('div', { className: 'overflow-x-auto' },
                  h('div', { className: 'grid grid-cols-7 gap-2 min-w-[700px]' },
                    getWeekDates(prefsWeekStart).map((date) => {
                      const dateKey = formatDateKey(date);
                      const dayShifts = groupShiftsByDate(shifts)[dateKey] || [];
                      const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                      const isToday = formatDateKey(new Date()) === dateKey;
                      return h('div', {
                        key: dateKey,
                        className: `border rounded-lg p-2 min-h-[120px] ${isToday ? 'border-indigo-300 bg-indigo-50/30' : 'border-slate-200'}`
                      },
                        h('div', { className: `text-center mb-2 pb-2 border-b ${isToday ? 'border-indigo-200' : 'border-slate-100'}` },
                          h('div', { className: 'text-xs text-slate-500' }, dayNames[date.getDay()]),
                          h('div', { className: `font-semibold ${isToday ? 'text-indigo-600' : 'text-slate-700'}` }, date.getDate())
                        ),
                        h('div', { className: 'space-y-2' },
                          dayShifts.map((s) => {
                            const pref = preferences[selectedParticipant]?.[s.id] ?? 0;
                            return h('button', {
                              key: s.id,
                              onClick: () => setPrefModal({ shift: s, participantId: selectedParticipant }),
                              className: `w-full text-left p-2 rounded text-xs cursor-pointer transition-colors hover:ring-2 hover:ring-indigo-300 ${pref > 0 ? 'bg-emerald-50' : 'bg-slate-100'}`
                            },
                              h('div', { className: 'font-medium text-slate-700 truncate' }, s.name),
                              s.time && h('div', { className: 'text-slate-500' }, s.time),
                              h('div', { className: 'text-indigo-600 font-medium' }, s.pa, ' PA'),
                              h('div', { className: 'flex gap-0.5 mt-1' },
                                [1, 2, 3, 4, 5].map((star) =>
                                  h(Star, {
                                    key: star,
                                    size: 12,
                                    className: star <= pref ? 'fill-amber-400 text-amber-400' : 'text-gray-300'
                                  })
                                )
                              )
                            );
                          })
                        )
                      );
                    })
                  )
                ),
                // Preference Modal
                prefModal && selectedParticipant && h(PreferenceModal, {
                  shift: prefModal.shift,
                  participant: participants.find(p => p.id === selectedParticipant),
                  preference: preferences[selectedParticipant]?.[prefModal.shift.id] ?? 0,
                  onSave: (value) => updatePref(selectedParticipant, prefModal.shift.id, value),
                  onClose: () => setPrefModal(null)
                }),
                !selectedParticipant && h('p', { className: 'text-slate-500 text-center py-8' }, 'Select a person above to set their preferences')
              ),
          shifts.length > 0 && participants.length > 0 &&
            h('button', {
              onClick: runOptimizer,
              disabled: isOptimizing,
              className: `mt-6 w-full py-3 rounded-lg font-medium flex items-center justify-center gap-2 ${
                isOptimizing
                  ? 'bg-slate-300 text-slate-500 cursor-not-allowed'
                  : 'bg-emerald-600 text-white hover:bg-emerald-700'
              }`
            }, h(Zap, { size: 20 }), isOptimizing ? ' Optimizing...' : ' Optimize Schedule')
        ),

        // Results Tab
        tab === 'results' && h('div', null,
          h('h2', { className: 'text-lg font-semibold mb-4' }, 'Optimized Schedule'),
          isOptimizing
            ? h('div', { className: 'py-12' },
                h('div', { className: 'flex flex-col items-center gap-4' },
                  // Spinner
                  h('div', { className: 'w-12 h-12 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin' }),
                  // Phase indicator
                  h('p', { className: 'text-lg font-medium text-slate-700' },
                    optimizeProgress?.phase === 'greedy' ? 'Building initial schedule...' :
                    optimizeProgress?.phase === 'local-search' ? 'Improving assignments...' :
                    optimizeProgress?.phase === 'annealing' ? 'Fine-tuning schedule...' :
                    'Optimizing...'
                  ),
                  // Restart indicator
                  optimizeProgress?.totalRestarts && h('p', { className: 'text-sm text-slate-500' },
                    `Pass ${optimizeProgress.restart || 1} of ${optimizeProgress.totalRestarts}`
                  ),
                  // Progress bar
                  h('div', { className: 'w-full max-w-md' },
                    h('div', { className: 'h-3 bg-slate-200 rounded-full overflow-hidden' },
                      h('div', {
                        className: 'h-full bg-indigo-600 transition-all duration-150',
                        style: { width: `${optimizeProgress?.progress || 0}%` }
                      })
                    ),
                    h('div', { className: 'flex justify-between mt-2 text-sm text-slate-500' },
                      h('span', null, `${(optimizeProgress?.progress || 0).toFixed(3)}% complete`),
                      h('span', null, `${(optimizeProgress?.iterations || 0).toLocaleString()} iterations`)
                    )
                  ),
                  // Best score so far
                  optimizeProgress?.bestScore !== null && h('p', { className: 'text-sm text-emerald-600' },
                    `Best score found: ${optimizeProgress.bestScore}`
                  )
                )
              )
            : !result
              ? (optimizationError
                ? h('div', { className: 'p-4 bg-red-50 border border-red-200 rounded-lg' },
                    h('p', { className: 'text-red-800 font-medium' }, optimizationError.message),
                    optimizationError.capacityShortfall && h('div', { className: 'mt-3' },
                      h('div', { className: 'grid grid-cols-3 gap-4 text-center' },
                        h('div', null,
                          h('div', { className: 'text-2xl font-bold text-red-700' }, optimizationError.capacityShortfall.required),
                          h('div', { className: 'text-xs text-red-600' }, 'PA Required')
                        ),
                        h('div', null,
                          h('div', { className: 'text-2xl font-bold text-amber-600' }, optimizationError.capacityShortfall.available),
                          h('div', { className: 'text-xs text-amber-600' }, 'PA Available')
                        ),
                        h('div', null,
                          h('div', { className: 'text-2xl font-bold text-red-700' }, optimizationError.capacityShortfall.shortfall),
                          h('div', { className: 'text-xs text-red-600' }, 'Shortfall')
                        )
                      ),
                      h('p', { className: 'mt-3 text-sm text-red-600' }, 'Add more participants or increase PA quotas to cover all shifts.')
                    ),
                    optimizationError.unavailableShifts && h('div', { className: 'mt-2' },
                      h('p', { className: 'text-red-600 text-sm' }, 'The following shifts have no one available:'),
                      h('ul', { className: 'mt-1 text-red-600 text-sm list-disc list-inside' },
                        optimizationError.unavailableShifts.map(shift =>
                          h('li', { key: shift.id }, `${shift.name} (${shift.date}${shift.time ? ' ' + shift.time : ''})`)
                        )
                      )
                    )
                  )
                : h('p', { className: 'text-slate-500 text-center py-8' }, 'Run the optimizer to see results'))
            : h('div', null,
                // Doctor search
                h('div', { className: 'mb-4' },
                  h('div', { className: 'relative' },
                    h(Search, { size: 16, className: 'absolute left-3 top-1/2 -translate-y-1/2 text-slate-400' }),
                    h('input', {
                      type: 'text',
                      placeholder: 'Search doctors...',
                      value: doctorSearch,
                      onChange: (e) => setDoctorSearch(e.target.value),
                      className: 'w-full pl-9 pr-3 py-2 border rounded-lg'
                    })
                  )
                ),
                result.quotasNotMet && h('div', { className: 'mb-4 p-4 bg-amber-50 border border-amber-200 rounded-lg' },
                  h('span', { className: 'text-amber-800 font-medium' }, 'âš ï¸ Could not satisfy all PA quotas. Showing best possible assignment.')
                ),
                h('div', { className: 'mb-4 p-4 bg-emerald-50 rounded-lg' },
                  h('span', { className: 'text-emerald-800 font-medium' }, `Total Satisfaction Score: ${result.score}`)
                ),
                h('h3', { className: 'font-medium text-slate-700 mb-2' }, 'PA Summary'),
                // Check for over-quota participants
                (() => {
                  const overQuota = participants.filter(p => (result.paTotals[p.id] || 0) > p.paQuota);
                  return overQuota.length > 0 && h('div', { className: 'mb-3 p-3 bg-amber-50 border border-amber-200 rounded-lg' },
                    h('p', { className: 'text-amber-800 font-medium text-sm' },
                      `âš ï¸ ${overQuota.length} participant${overQuota.length > 1 ? 's' : ''} assigned more than their quota`
                    )
                  );
                })(),
                h('div', { className: 'grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-3 mb-6' },
                  participants
                    .filter(p => !doctorSearch || p.name.toLowerCase().includes(doctorSearch.toLowerCase()))
                    .map((p) => {
                      const assigned = result.paTotals[p.id] || 0;
                      const underQuota = assigned < p.paQuota;
                      const overQuota = assigned > p.paQuota;
                      const isHighlighted = doctorSearch && p.name.toLowerCase().includes(doctorSearch.toLowerCase());
                      const bgColor = overQuota ? 'bg-amber-50 border border-amber-300' : underQuota ? 'bg-red-50' : 'bg-emerald-50';
                      const textColor = overQuota ? 'text-amber-700' : underQuota ? 'text-red-700' : 'text-emerald-700';
                      const icon = overQuota ? 'âš ï¸' : underQuota ? 'âœ—' : 'âœ“';
                      return h('div', { key: p.id, className: `p-3 rounded-lg ${bgColor} ${isHighlighted ? 'ring-2 ring-indigo-400' : ''}` },
                        h('div', { className: 'font-medium' }, p.name),
                        h('div', { className: `text-sm ${textColor}` },
                          assigned, ' / ', p.paQuota, ' PA ', icon,
                          overQuota && h('span', { className: 'ml-1 text-xs' }, `(+${(assigned - p.paQuota).toFixed(1)} over)`)
                        )
                      );
                    })
                ),
                h('h3', { className: 'font-medium text-slate-700 mb-2' }, 'Shift Assignments'),
                // Results week navigation
                h('div', { className: 'flex items-center justify-between mb-4' },
                  h('button', {
                    onClick: () => navigateResultsWeek(-1),
                    className: 'p-2 text-slate-600 hover:bg-slate-100 rounded-lg'
                  }, h(ChevronLeft, { size: 20 })),
                  h('div', { className: 'flex items-center gap-2' },
                    h('span', { className: 'font-medium text-slate-700' }, formatWeekRange(resultsWeekStart)),
                    shifts.length > 0 && h('button', {
                      onClick: jumpToResultsWeek,
                      className: 'text-xs px-2 py-1 bg-indigo-100 text-indigo-700 rounded hover:bg-indigo-200'
                    }, 'Go to shifts')
                  ),
                  h('button', {
                    onClick: () => navigateResultsWeek(1),
                    className: 'p-2 text-slate-600 hover:bg-slate-100 rounded-lg'
                  }, h(ChevronRight, { size: 20 }))
                ),
                // Results calendar grid
                h('div', { className: 'overflow-x-auto' },
                  h('div', { className: 'grid grid-cols-7 gap-2 min-w-[700px]' },
                    getWeekDates(resultsWeekStart).map((date) => {
                      const dateKey = formatDateKey(date);
                      const dayShifts = (groupShiftsByDate(shifts)[dateKey] || []).filter(s => {
                        if (!doctorSearch) return true;
                        const assignedId = result.assignment[s.id];
                        const person = participants.find(p => p.id === assignedId);
                        return person && person.name.toLowerCase().includes(doctorSearch.toLowerCase());
                      });
                      const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                      const isToday = formatDateKey(new Date()) === dateKey;
                      return h('div', {
                        key: dateKey,
                        className: `border rounded-lg p-2 min-h-[120px] ${isToday ? 'border-indigo-300 bg-indigo-50/30' : 'border-slate-200'}`
                      },
                        h('div', { className: `text-center mb-2 pb-2 border-b ${isToday ? 'border-indigo-200' : 'border-slate-100'}` },
                          h('div', { className: 'text-xs text-slate-500' }, dayNames[date.getDay()]),
                          h('div', { className: `font-semibold ${isToday ? 'text-indigo-600' : 'text-slate-700'}` }, date.getDate())
                        ),
                        h('div', { className: 'space-y-1' },
                          dayShifts.map((s) => {
                            const assignedId = result.assignment[s.id];
                            const person = participants.find((p) => p.id === assignedId);
                            const pref = assignedId ? (preferences[assignedId]?.[s.id] ?? 0) : 0;
                            const isHighlighted = doctorSearch && person && person.name.toLowerCase().includes(doctorSearch.toLowerCase());
                            return h('div', {
                              key: s.id,
                              className: `p-2 rounded text-xs ${isHighlighted ? 'bg-indigo-100 ring-2 ring-indigo-400' : 'bg-slate-100'}`
                            },
                              h('div', { className: 'font-medium text-slate-700 truncate' }, s.name),
                              s.time && h('div', { className: 'text-slate-500' }, s.time),
                              h('div', { className: 'text-indigo-600 font-medium' }, s.pa, ' PA'),
                              h('div', { className: 'mt-1 pt-1 border-t border-slate-200' },
                                person
                                  ? h('div', null,
                                      h('div', { className: 'font-medium text-emerald-700 truncate' }, person.name),
                                      h('div', { className: 'flex mt-0.5' },
                                        [1,2,3,4,5].map((star) =>
                                          h(Star, {
                                            key: star,
                                            size: 10,
                                            className: star <= pref ? 'fill-amber-400 text-amber-400' : 'text-gray-300'
                                          })
                                        )
                                      )
                                    )
                                  : h('span', { className: 'text-red-500 font-medium' }, 'Unassigned')
                              )
                            );
                          })
                        )
                      );
                    })
                  )
                )
              )
        )
      )
    )
  );
}

// Mount the app
const root = createRoot(document.getElementById('root'));
root.render(h(ShiftOptimizer));
    </script>
</body>
</html>
